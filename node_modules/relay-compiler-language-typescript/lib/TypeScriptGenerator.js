"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var relay_compiler_1 = require("relay-compiler");
var FlattenTransform = require("relay-compiler/lib/transforms/FlattenTransform");
var MaskTransform = require("relay-compiler/lib/transforms/MaskTransform");
var MatchTransform = require("relay-compiler/lib/transforms/MatchTransform");
var RefetchableFragmentTransform = require("relay-compiler/lib/transforms/RefetchableFragmentTransform");
var RelayDirectiveTransform = require("relay-compiler/lib/transforms/RelayDirectiveTransform");
var ts = require("typescript");
var TypeScriptTypeTransformers_1 = require("./TypeScriptTypeTransformers");
var REF_TYPE = " $refType";
var FRAGMENT_REFS = " $fragmentRefs";
var DATA_REF = " $data";
var FRAGMENT_REFS_TYPE_NAME = "FragmentRefs";
var DIRECTIVE_NAME = "raw_response_type";
exports.generate = function (schema, node, options) {
    var ast = aggregateRuntimeImports(relay_compiler_1.IRVisitor.visit(node, createVisitor(schema, options)));
    var printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    var resultFile = ts.createSourceFile("grapghql-def.ts", "", ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
    var fullProgramAst = ts.updateSourceFileNode(resultFile, ast);
    return printer.printNode(ts.EmitHint.SourceFile, fullProgramAst, resultFile);
};
function aggregateRuntimeImports(ast) {
    var importNodes = ast.filter(function (declaration) {
        return ts.isImportDeclaration(declaration);
    });
    var runtimeImports = importNodes.filter(function (importDeclaration) {
        return importDeclaration.moduleSpecifier.text ===
            "relay-runtime";
    });
    if (runtimeImports.length > 1) {
        var namedImports_1 = [];
        runtimeImports.map(function (node) {
            node.importClause.namedBindings.elements.map(function (element) {
                namedImports_1.push(element.name.text);
            });
        });
        var importSpecifiers_1 = [];
        namedImports_1.map(function (namedImport) {
            var specifier = ts.createImportSpecifier(undefined, ts.createIdentifier(namedImport));
            importSpecifiers_1.push(specifier);
        });
        var namedBindings = ts.createNamedImports(importSpecifiers_1);
        var aggregatedRuntimeImportDeclaration = ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, namedBindings), ts.createStringLiteral("relay-runtime"));
        var aggregatedRuntimeImportAST = ast.reduce(function (prev, curr) {
            if (!ts.isImportDeclaration(curr))
                prev.push(curr);
            return prev;
        }, [aggregatedRuntimeImportDeclaration]);
        return aggregatedRuntimeImportAST;
    }
    else {
        return ast;
    }
}
function nullthrows(obj) {
    if (obj == null) {
        throw new Error("Obj is null");
    }
    return obj;
}
function makeProp(schema, selection, state, unmasked, concreteType) {
    var value = selection.value;
    var key = selection.key, schemaName = selection.schemaName, conditional = selection.conditional, nodeType = selection.nodeType, nodeSelections = selection.nodeSelections;
    if (schemaName === "__typename" && concreteType) {
        value = ts.createLiteralTypeNode(ts.createLiteral(concreteType));
    }
    else if (nodeType) {
        value = TypeScriptTypeTransformers_1.transformScalarType(schema, nodeType, state, selectionsToAST(schema, [Array.from(nullthrows(nodeSelections).values())], state, unmasked));
    }
    var typeProperty = objectTypeProperty(key, value);
    if (conditional) {
        typeProperty.questionToken = ts.createToken(ts.SyntaxKind.QuestionToken);
    }
    return typeProperty;
}
var isTypenameSelection = function (selection) {
    return selection.schemaName === "__typename";
};
var hasTypenameSelection = function (selections) {
    return selections.some(isTypenameSelection);
};
var onlySelectsTypename = function (selections) {
    return selections.every(isTypenameSelection);
};
function selectionsToAST(schema, selections, state, unmasked, fragmentTypeName) {
    var baseFields = new Map();
    var byConcreteType = {};
    flattenArray(selections).forEach(function (selection) {
        var concreteType = selection.concreteType;
        if (concreteType) {
            byConcreteType[concreteType] = byConcreteType[concreteType] || [];
            byConcreteType[concreteType].push(selection);
        }
        else {
            var previousSel = baseFields.get(selection.key);
            baseFields.set(selection.key, previousSel ? mergeSelection(selection, previousSel) : selection);
        }
    });
    var types = [];
    if (Object.keys(byConcreteType).length > 0 &&
        onlySelectsTypename(Array.from(baseFields.values())) &&
        (hasTypenameSelection(Array.from(baseFields.values())) ||
            Object.keys(byConcreteType).every(function (type) {
                return hasTypenameSelection(byConcreteType[type]);
            }))) {
        var typenameAliases_1 = new Set();
        var _loop_1 = function (concreteType) {
            types.push(groupRefs(__spread(Array.from(baseFields.values()), byConcreteType[concreteType])).map(function (selection) {
                if (selection.schemaName === "__typename") {
                    typenameAliases_1.add(selection.key);
                }
                return makeProp(schema, selection, state, unmasked, concreteType);
            }));
        };
        for (var concreteType in byConcreteType) {
            _loop_1(concreteType);
        }
        // It might be some other type then the listed concrete types. Ideally, we
        // would set the type to diff(string, set of listed concrete types), but
        // this doesn't exist in Flow at the time.
        types.push(Array.from(typenameAliases_1).map(function (typenameAlias) {
            var otherProp = objectTypeProperty(typenameAlias, ts.createLiteralTypeNode(ts.createLiteral("%other")));
            var otherPropWithComment = ts.addSyntheticLeadingComment(otherProp, ts.SyntaxKind.MultiLineCommentTrivia, "This will never be '%other', but we need some\n" +
                "value in case none of the concrete values match.", true);
            return otherPropWithComment;
        }));
    }
    else {
        var selectionMap = selectionsToMap(Array.from(baseFields.values()));
        for (var concreteType in byConcreteType) {
            selectionMap = mergeSelections(selectionMap, selectionsToMap(byConcreteType[concreteType].map(function (sel) { return (__assign(__assign({}, sel), { conditional: true })); })));
        }
        var selectionMapValues = groupRefs(Array.from(selectionMap.values())).map(function (sel) {
            return isTypenameSelection(sel) && sel.concreteType
                ? makeProp(schema, __assign(__assign({}, sel), { conditional: false }), state, unmasked, sel.concreteType)
                : makeProp(schema, sel, state, unmasked);
        });
        types.push(selectionMapValues);
    }
    var typeElements = types.map(function (props) {
        if (fragmentTypeName) {
            props.push(objectTypeProperty(REF_TYPE, ts.createLiteralTypeNode(ts.createStringLiteral(fragmentTypeName))));
        }
        return unmasked
            ? ts.createTypeLiteralNode(props)
            : exactObjectTypeAnnotation(props);
    });
    if (typeElements.length === 1) {
        return typeElements[0];
    }
    return ts.createUnionTypeNode(typeElements);
}
// We don't have exact object types in typescript.
function exactObjectTypeAnnotation(properties) {
    return ts.createTypeLiteralNode(properties);
}
var idRegex = /^[$a-zA-Z_][$a-z0-9A-Z_]*$/;
function objectTypeProperty(propertyName, type, options) {
    if (options === void 0) { options = {}; }
    var optional = options.optional, _a = options.readonly, readonly = _a === void 0 ? true : _a;
    var modifiers = readonly
        ? [ts.createToken(ts.SyntaxKind.ReadonlyKeyword)]
        : undefined;
    return ts.createPropertySignature(modifiers, idRegex.test(propertyName)
        ? ts.createIdentifier(propertyName)
        : ts.createLiteral(propertyName), optional ? ts.createToken(ts.SyntaxKind.QuestionToken) : undefined, type, undefined);
}
function mergeSelection(a, b, shouldSetConditional) {
    if (shouldSetConditional === void 0) { shouldSetConditional = true; }
    if (!a) {
        if (shouldSetConditional) {
            return __assign(__assign({}, b), { conditional: true });
        }
        return b;
    }
    return __assign(__assign({}, a), { nodeSelections: a.nodeSelections
            ? mergeSelections(a.nodeSelections, nullthrows(b.nodeSelections), shouldSetConditional)
            : null, conditional: a.conditional && b.conditional });
}
function mergeSelections(a, b, shouldSetConditional) {
    var e_1, _a, e_2, _b;
    if (shouldSetConditional === void 0) { shouldSetConditional = true; }
    var merged = new Map();
    try {
        for (var _c = __values(Array.from(a.entries())), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
            merged.set(key, value);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _f = __values(Array.from(b.entries())), _g = _f.next(); !_g.done; _g = _f.next()) {
            var _h = __read(_g.value, 2), key = _h[0], value = _h[1];
            merged.set(key, mergeSelection(a.get(key), value, shouldSetConditional));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return merged;
}
function isPlural(node) {
    return Boolean(node.metadata && node.metadata.plural);
}
function exportType(name, type) {
    return ts.createTypeAliasDeclaration(undefined, [ts.createToken(ts.SyntaxKind.ExportKeyword)], ts.createIdentifier(name), undefined, type);
}
function importTypes(names, fromModule) {
    return (names &&
        ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports(names.map(function (name) {
            return ts.createImportSpecifier(undefined, ts.createIdentifier(name));
        }))), ts.createLiteral(fromModule)));
}
function createVisitor(schema, options) {
    var state = {
        customScalars: options.customScalars,
        enumsHasteModule: options.enumsHasteModule,
        existingFragmentNames: options.existingFragmentNames,
        generatedFragments: new Set(),
        generatedInputObjectTypes: {},
        optionalInputFields: options.optionalInputFields,
        usedEnums: {},
        usedFragments: new Set(),
        useHaste: options.useHaste,
        useSingleArtifactDirectory: options.useSingleArtifactDirectory,
        noFutureProofEnums: options.noFutureProofEnums,
        matchFields: new Map(),
        runtimeImports: new Set()
    };
    return {
        leave: {
            Root: function (node) {
                var e_3, _a;
                var inputVariablesType = generateInputVariablesType(schema, node, state);
                var inputObjectTypes = generateInputObjectTypes(state);
                var responseType = exportType(node.name + "Response", selectionsToAST(schema, 
                /* $FlowFixMe: selections have already been transformed */
                node.selections, state, false));
                var operationTypes = [
                    objectTypeProperty("response", ts.createTypeReferenceNode(responseType.name, undefined)),
                    objectTypeProperty("variables", ts.createTypeReferenceNode(inputVariablesType.name, undefined))
                ];
                // Generate raw response type
                var rawResponseType;
                var normalizationIR = options.normalizationIR;
                if (normalizationIR &&
                    node.directives.some(function (d) { return d.name === DIRECTIVE_NAME; })) {
                    rawResponseType = relay_compiler_1.IRVisitor.visit(normalizationIR, createRawResponseTypeVisitor(schema, state));
                }
                var nodes = [];
                if (state.runtimeImports.size) {
                    nodes.push(importTypes(Array.from(state.runtimeImports).sort(), "relay-runtime"));
                }
                nodes.push.apply(nodes, __spread(getFragmentRefsTypeImport(state), getEnumDefinitions(schema, state), inputObjectTypes, [inputVariablesType,
                    responseType]));
                if (rawResponseType) {
                    try {
                        for (var _b = __values(state.matchFields), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var _d = __read(_c.value, 2), key = _d[0], ast = _d[1];
                            nodes.push(exportType(key, ast));
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    operationTypes.push(objectTypeProperty("rawResponse", ts.createTypeReferenceNode(node.name + "RawResponse", undefined)));
                    nodes.push(rawResponseType);
                }
                nodes.push(exportType(node.name, exactObjectTypeAnnotation(operationTypes)));
                return nodes;
            },
            Fragment: function (node) {
                var flattenedSelections = flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections);
                var numConcreteSelections = flattenedSelections.filter(function (s) { return s.concreteType; }).length;
                var selections = flattenedSelections.map(function (selection) {
                    if (numConcreteSelections <= 1 &&
                        isTypenameSelection(selection) &&
                        !schema.isAbstractType(node.type)) {
                        return [
                            __assign(__assign({}, selection), { concreteType: schema.getTypeString(node.type) })
                        ];
                    }
                    return [selection];
                });
                state.generatedFragments.add(node.name);
                var dataTypeName = getDataTypeName(node.name);
                var dataType = ts.createTypeReferenceNode(node.name, undefined);
                var refTypeName = getRefTypeName(node.name);
                var refTypeDataProperty = objectTypeProperty(DATA_REF, ts.createTypeReferenceNode(dataTypeName, undefined), { optional: true });
                refTypeDataProperty.questionToken = ts.createToken(ts.SyntaxKind.QuestionToken);
                var refTypeFragmentRefProperty = objectTypeProperty(FRAGMENT_REFS, ts.createTypeReferenceNode(FRAGMENT_REFS_TYPE_NAME, [
                    ts.createLiteralTypeNode(ts.createStringLiteral(node.name))
                ]));
                var isPluralFragment = isPlural(node);
                var refType = exactObjectTypeAnnotation([
                    refTypeDataProperty,
                    refTypeFragmentRefProperty
                ]);
                var unmasked = node.metadata != null && node.metadata.mask === false;
                var baseType = selectionsToAST(schema, selections, state, unmasked, unmasked ? undefined : node.name);
                var type = isPlural(node)
                    ? ts.createTypeReferenceNode(ts.createIdentifier("ReadonlyArray"), [
                        baseType
                    ])
                    : baseType;
                state.runtimeImports.add("FragmentRefs");
                return __spread([
                    importTypes(Array.from(state.runtimeImports).sort(), "relay-runtime")
                ], getEnumDefinitions(schema, state), [
                    exportType(node.name, type),
                    exportType(dataTypeName, dataType),
                    exportType(refTypeName, isPluralFragment
                        ? ts.createTypeReferenceNode(ts.createIdentifier("ReadonlyArray"), [refType])
                        : refType)
                ]);
            },
            InlineFragment: function (node) {
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections).map(function (typeSelection) {
                    return schema.isAbstractType(node.typeCondition)
                        ? __assign(__assign({}, typeSelection), { conditional: true }) : __assign(__assign({}, typeSelection), { concreteType: schema.getTypeString(node.typeCondition) });
                });
            },
            Condition: function (node) {
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections).map(function (selection) {
                    return __assign(__assign({}, selection), { conditional: true });
                });
            },
            // TODO: Why not inline it like others?
            ScalarField: function (node) {
                return visitScalarField(schema, node, state);
            },
            LinkedField: visitLinkedField,
            ModuleImport: function (node) {
                return [
                    {
                        key: "__fragmentPropName",
                        conditional: true,
                        value: TypeScriptTypeTransformers_1.transformScalarType(schema, schema.expectStringType(), state)
                    },
                    {
                        key: "__module_component",
                        conditional: true,
                        value: TypeScriptTypeTransformers_1.transformScalarType(schema, schema.expectStringType(), state)
                    },
                    {
                        key: "__fragments_" + node.name,
                        ref: node.name
                    }
                ];
            },
            FragmentSpread: function (node) {
                state.usedFragments.add(node.name);
                return [
                    {
                        key: "__fragments_" + node.name,
                        ref: node.name
                    }
                ];
            }
        }
    };
}
function visitScalarField(schema, node, state) {
    return [
        {
            key: node.alias || node.name,
            schemaName: node.name,
            value: TypeScriptTypeTransformers_1.transformScalarType(schema, node.type, state)
        }
    ];
}
function visitLinkedField(node) {
    return [
        {
            key: node.alias || node.name,
            schemaName: node.name,
            nodeType: node.type,
            nodeSelections: selectionsToMap(flattenArray(
            /* $FlowFixMe: selections have already been transformed */
            node.selections), 
            /*
             * append concreteType to key so overlapping fields with different
             * concreteTypes don't get overwritten by each other
             */
            true)
        }
    ];
}
function makeRawResponseProp(schema, _a, state, concreteType) {
    var key = _a.key, schemaName = _a.schemaName, value = _a.value, conditional = _a.conditional, nodeType = _a.nodeType, nodeSelections = _a.nodeSelections, kind = _a.kind;
    if (kind === "ModuleImport") {
        // TODO: In flow one can extend an object type with spread, with TS we need an intersection (&)
        // return ts.createSpread(ts.createIdentifier(key));
        throw new Error("relay-compiler-language-typescript does not support @module yet");
    }
    if (schemaName === "__typename" && concreteType) {
        value = ts.createLiteralTypeNode(ts.createLiteral(concreteType));
    }
    else if (nodeType) {
        value = TypeScriptTypeTransformers_1.transformScalarType(schema, nodeType, state, selectionsToRawResponseBabel(schema, [Array.from(nullthrows(nodeSelections).values())], state, schema.isAbstractType(nodeType) || schema.isWrapper(nodeType)
            ? null
            : schema.getTypeString(nodeType)));
    }
    var typeProperty = objectTypeProperty(key, value);
    if (conditional) {
        typeProperty.questionToken = ts.createToken(ts.SyntaxKind.QuestionToken);
    }
    return typeProperty;
}
function selectionsToMap(selections, appendType) {
    var map = new Map();
    selections.forEach(function (selection) {
        var key = appendType && selection.concreteType
            ? selection.key + "::" + selection.concreteType
            : selection.key;
        var previousSel = map.get(key);
        map.set(key, previousSel ? mergeSelection(previousSel, selection) : selection);
    });
    return map;
}
// Transform the codegen IR selections into TS types
function selectionsToRawResponseBabel(schema, selections, state, nodeTypeName) {
    var baseFields = [];
    var byConcreteType = {};
    flattenArray(selections).forEach(function (selection) {
        var concreteType = selection.concreteType;
        if (concreteType) {
            byConcreteType[concreteType] = byConcreteType[concreteType] || [];
            byConcreteType[concreteType].push(selection);
        }
        else {
            baseFields.push(selection);
        }
    });
    var types = [];
    if (Object.keys(byConcreteType).length) {
        var baseFieldsMap = selectionsToMap(baseFields);
        var _loop_2 = function (concreteType) {
            var mergedSeletions = Array.from(mergeSelections(baseFieldsMap, selectionsToMap(byConcreteType[concreteType]), false).values());
            types.push(exactObjectTypeAnnotation(mergedSeletions.map(function (selection) {
                return makeRawResponseProp(schema, selection, state, concreteType);
            })));
            appendLocal3DPayload(types, mergedSeletions, schema, state, concreteType);
        };
        for (var concreteType in byConcreteType) {
            _loop_2(concreteType);
        }
    }
    if (baseFields.length > 0) {
        types.push(exactObjectTypeAnnotation(baseFields.map(function (selection) {
            return makeRawResponseProp(schema, selection, state, nodeTypeName);
        })));
        appendLocal3DPayload(types, baseFields, schema, state, nodeTypeName);
    }
    return ts.createUnionTypeNode(types);
}
function appendLocal3DPayload(types, selections, schema, state, currentType) {
    var moduleImport = selections.find(function (sel) { return sel.kind === "ModuleImport"; });
    if (moduleImport) {
        // Generate an extra opaque type for client 3D fields
        state.runtimeImports.add("Local3DPayload");
        types.push(ts.createTypeReferenceNode(ts.createIdentifier("Local3DPayload"), [
            stringLiteralTypeAnnotation(moduleImport.documentName),
            exactObjectTypeAnnotation(selections
                .filter(function (sel) { return sel.schemaName !== "js"; })
                .map(function (selection) {
                return makeRawResponseProp(schema, selection, state, currentType);
            }))
        ]));
    }
}
// Visitor for generating raw response type
function createRawResponseTypeVisitor(schema, state) {
    return {
        leave: {
            Root: function (node) {
                return exportType(node.name + "RawResponse", selectionsToRawResponseBabel(schema, 
                /* $FlowFixMe: selections have already been transformed */
                node.selections, state, null));
            },
            InlineFragment: function (node) {
                var typeCondition = node.typeCondition;
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections).map(function (typeSelection) {
                    return schema.isAbstractType(typeCondition)
                        ? typeSelection
                        : __assign(__assign({}, typeSelection), { concreteType: schema.getTypeString(typeCondition) });
                });
            },
            ScalarField: function (node) {
                return visitScalarField(schema, node, state);
            },
            ClientExtension: function (node) {
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections).map(function (sel) { return (__assign(__assign({}, sel), { conditional: true })); });
            },
            LinkedField: visitLinkedField,
            Condition: function (node) {
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections);
            },
            Defer: function (node) {
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections);
            },
            Stream: function (node) {
                return flattenArray(
                /* $FlowFixMe: selections have already been transformed */
                node.selections);
            },
            ModuleImport: function (node) {
                return visitRawResponseModuleImport(schema, node, state);
            },
            FragmentSpread: function (_node) {
                throw new Error("A fragment spread is found when traversing the AST, " +
                    "make sure you are passing the codegen IR");
            }
        }
    };
}
// Dedupe the generated type of module selections to reduce file size
function visitRawResponseModuleImport(schema, node, state) {
    var selections = node.selections, key = node.name;
    var moduleSelections = selections
        .filter(function (sel) { return sel.length && sel[0].schemaName === "js"; })
        .map(function (arr) { return arr[0]; });
    if (!state.matchFields.has(key)) {
        var ast = selectionsToRawResponseBabel(schema, node.selections.filter(function (sel) { return sel.length > 1 || sel[0].schemaName !== "js"; }), state, null);
        state.matchFields.set(key, ast);
    }
    return __spread(moduleSelections, [
        {
            key: key,
            kind: "ModuleImport",
            documentName: node.documentName
        }
    ]);
}
function flattenArray(arrayOfArrays) {
    var result = [];
    arrayOfArrays.forEach(function (array) { return result.push.apply(result, __spread(array)); });
    return result;
}
function generateInputObjectTypes(state) {
    return Object.keys(state.generatedInputObjectTypes).map(function (typeIdentifier) {
        var inputObjectType = state.generatedInputObjectTypes[typeIdentifier];
        if (inputObjectType === "pending") {
            throw new Error("TypeScriptGenerator: Expected input object type to have been" +
                " defined before calling `generateInputObjectTypes`");
        }
        else {
            return exportType(typeIdentifier, inputObjectType);
        }
    });
}
function generateInputVariablesType(schema, node, state) {
    return exportType(node.name + "Variables", exactObjectTypeAnnotation(node.argumentDefinitions.map(function (arg) {
        return objectTypeProperty(arg.name, TypeScriptTypeTransformers_1.transformInputType(schema, arg.type, state), { readonly: false, optional: !schema.isNonNull(arg.type) });
    })));
}
function groupRefs(props) {
    var result = [];
    var refs = [];
    props.forEach(function (prop) {
        if (prop.ref) {
            refs.push(prop.ref);
        }
        else {
            result.push(prop);
        }
    });
    if (refs.length > 0) {
        var refTypes = ts.createUnionTypeNode(refs.map(function (ref) { return ts.createLiteralTypeNode(ts.createStringLiteral(ref)); }));
        result.push({
            key: FRAGMENT_REFS,
            conditional: false,
            value: ts.createTypeReferenceNode(FRAGMENT_REFS_TYPE_NAME, [refTypes])
        });
    }
    return result;
}
function getFragmentRefsTypeImport(state) {
    if (state.usedFragments.size > 0) {
        return [
            ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports([
                ts.createImportSpecifier(undefined, ts.createIdentifier("FragmentRefs"))
            ])), ts.createStringLiteral("relay-runtime"))
        ];
    }
    return [];
}
function getEnumDefinitions(schema, _a) {
    var enumsHasteModule = _a.enumsHasteModule, usedEnums = _a.usedEnums, noFutureProofEnums = _a.noFutureProofEnums;
    var enumNames = Object.keys(usedEnums).sort();
    if (enumNames.length === 0) {
        return [];
    }
    if (typeof enumsHasteModule === "string") {
        return [importTypes(enumNames, enumsHasteModule)];
    }
    if (typeof enumsHasteModule === "function") {
        return enumNames.map(function (enumName) {
            return importTypes([enumName], enumsHasteModule(enumName));
        });
    }
    return enumNames.map(function (name) {
        var values = __spread(schema.getEnumValues(usedEnums[name]));
        values.sort();
        if (!noFutureProofEnums) {
            values.push("%future added value");
        }
        return exportType(name, ts.createUnionTypeNode(values.map(function (value) { return stringLiteralTypeAnnotation(value); })));
    });
}
function stringLiteralTypeAnnotation(name) {
    return ts.createLiteralTypeNode(ts.createLiteral(name));
}
function getRefTypeName(name) {
    return name + "$key";
}
function getDataTypeName(name) {
    return name + "$data";
}
// Should match FLOW_TRANSFORMS array
// https://github.com/facebook/relay/blob/v6.0.0/packages/relay-compiler/language/javascript/RelayFlowGenerator.js#L621-L627
exports.transforms = [
    RelayDirectiveTransform.transform,
    MaskTransform.transform,
    MatchTransform.transform,
    FlattenTransform.transformWithOptions({}),
    RefetchableFragmentTransform.transform
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHlwZVNjcmlwdEdlbmVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9UeXBlU2NyaXB0R2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaURBVXdCO0FBRXhCLGlGQUFtRjtBQUNuRiwyRUFBNkU7QUFDN0UsNkVBQStFO0FBQy9FLHlHQUEyRztBQUMzRywrRkFBaUc7QUFDakcsK0JBQWlDO0FBQ2pDLDJFQUlzQztBQWlCdEMsSUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDO0FBQzdCLElBQU0sYUFBYSxHQUFHLGdCQUFnQixDQUFDO0FBQ3ZDLElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUMxQixJQUFNLHVCQUF1QixHQUFHLGNBQWMsQ0FBQztBQUMvQyxJQUFNLGNBQWMsR0FBRyxtQkFBbUIsQ0FBQztBQUU5QixRQUFBLFFBQVEsR0FBOEIsVUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU87SUFDdkUsSUFBTSxHQUFHLEdBQW1CLHVCQUF1QixDQUNqRCwwQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUN0RCxDQUFDO0lBRUYsSUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFFdkUsSUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUNwQyxpQkFBaUIsRUFDakIsRUFBRSxFQUNGLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUN0QixLQUFLLEVBQ0wsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQ2pCLENBQUM7SUFFRixJQUFNLGNBQWMsR0FBRyxFQUFFLENBQUMsb0JBQW9CLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FB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